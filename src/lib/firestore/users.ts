// src/lib/firestore/users.ts
import {
	doc,
	getDoc,
	setDoc,
	updateDoc,
	collection,
	query,
	where,
	onSnapshot,
	serverTimestamp,
	Timestamp
} from 'firebase/firestore';
import { User as FirebaseUser } from 'firebase/auth';
import { db } from '@/lib/firebase';
import {
	FirestoreUser,
	CreateUserData,
	UpdateUserProfile,
	UpdateUserStats,
	ProfileCompleteness
} from '../../../types/user';
import { UserProfile } from '../../../types/dashboard';

// ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å
const USERS_COLLECTION = 'users';

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
 */
export const checkUserExists = async (userId: string): Promise<boolean> => {
	try {
		const userRef = doc(db, USERS_COLLECTION, userId);
		const userSnap = await getDoc(userRef);
		return userSnap.exists();
	} catch (error) {
		console.error('Error checking user existence:', error);
		return false;
	}
};

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§Firestoreãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
 */
export const getUserById = async (userId: string): Promise<FirestoreUser | null> => {
	try {
		const userRef = doc(db, USERS_COLLECTION, userId);
		const userSnap = await getDoc(userRef);

		if (userSnap.exists()) {
			return { id: userSnap.id, ...userSnap.data() } as FirestoreUser;
		}
		return null;
	} catch (error) {
		console.error('Error getting user:', error);
		return null;
	}
};

/**
 * EmptyUserãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
 */
export const generateEmptyUserData = (firebaseUser: FirebaseUser): CreateUserData => {
	return {
		id: firebaseUser.uid,
		email: firebaseUser.email || '',
		displayName: firebaseUser.displayName || firebaseUser.email?.split('@')[0] || 'Anonymous User',
		nickname: firebaseUser.displayName || undefined,
		profileImage: firebaseUser.photoURL || undefined,
		address: {},
		isEmailVerified: firebaseUser.emailVerified,
		isActive: true,
		membershipTier: 'bronze',
		isProfileComplete: false,
		stats: {
			totalSpent: 0,
			totalSpentUSD: 0,
			totalOrders: 0,
			rank: 999999,
			badges: ['New Member']
		}
	};
};

/**
 * æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’Firestoreã«ä½œæˆ
 */
export const createEmptyUser = async (firebaseUser: FirebaseUser): Promise<FirestoreUser> => {
	try {
		const userData = generateEmptyUserData(firebaseUser);
		const userRef = doc(db, USERS_COLLECTION, firebaseUser.uid);

		const firestoreUserData = {
			...userData,
			createdAt: serverTimestamp(),
			updatedAt: serverTimestamp(),
			lastLoginAt: serverTimestamp(),
		};

		await setDoc(userRef, firestoreUserData);

		// ä½œæˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™ï¼ˆserverTimestampã¯Firestoreã§è‡ªå‹•å¤‰æ›ã•ã‚Œã‚‹ï¼‰
		const createdUser = await getUserById(firebaseUser.uid);
		if (!createdUser) {
			throw new Error('Failed to retrieve created user');
		}

		console.log('âœ… New user created in Firestore:', firebaseUser.uid);
		return createdUser;
	} catch (error) {
		console.error('Error creating empty user:', error);
		throw error;
	}
};

/**
 * æœ€çµ‚ãƒ­ã‚°ã‚¤ãƒ³æ™‚åˆ»ã‚’æ›´æ–°
 */
export const updateLastLogin = async (userId: string): Promise<void> => {
	try {
		const userRef = doc(db, USERS_COLLECTION, userId);
		await updateDoc(userRef, {
			lastLoginAt: serverTimestamp(),
			updatedAt: serverTimestamp()
		});
		console.log('âœ… Last login updated for user:', userId);
	} catch (error) {
		console.error('Error updating last login:', error);
		throw error;
	}
};

/**
 * ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’æ›´æ–°
 */
export const updateUserProfile = async (
	userId: string,
	profileData: UpdateUserProfile
): Promise<void> => {
	try {
		const userRef = doc(db, USERS_COLLECTION, userId);
		await updateDoc(userRef, {
			...profileData,
			updatedAt: serverTimestamp()
		});
		console.log('âœ… User profile updated:', userId);
	} catch (error) {
		console.error('Error updating user profile:', error);
		throw error;
	}
};

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼çµ±è¨ˆã‚’æ›´æ–°
 */
export const updateUserStats = async (
	userId: string,
	statsData: UpdateUserStats
): Promise<void> => {
	try {
		const userRef = doc(db, USERS_COLLECTION, userId);
		await updateDoc(userRef, {
			'stats.totalSpent': statsData.totalSpent,
			'stats.totalSpentUSD': statsData.totalSpentUSD,
			'stats.totalOrders': statsData.totalOrders,
			'stats.rank': statsData.rank,
			'stats.badges': statsData.badges,
			updatedAt: serverTimestamp()
		});
		console.log('âœ… User stats updated:', userId);
	} catch (error) {
		console.error('Error updating user stats:', error);
		throw error;
	}
};

/**
 * Firebase Authã¨Firestoreã®è‡ªå‹•åŒæœŸï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
 */
export const syncAuthWithFirestore = async (firebaseUser: FirebaseUser): Promise<FirestoreUser> => {
	try {
		// 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼å­˜åœ¨ç¢ºèª
		const existingUser = await getUserById(firebaseUser.uid);

		if (!existingUser) {
			// 2. å­˜åœ¨ã—ãªã„å ´åˆï¼šEmptyUserã‚’ä½œæˆ
			console.log('ğŸ†• Creating new user in Firestore:', firebaseUser.uid);
			return await createEmptyUser(firebaseUser);
		} else {
			// 3. å­˜åœ¨ã™ã‚‹å ´åˆï¼šlastLoginAtã‚’æ›´æ–°ï¼ˆãŸã ã—ã€æœ€å¾Œã®æ›´æ–°ã‹ã‚‰5åˆ†ä»¥ä¸ŠçµŒéã—ã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
			const now = new Date();
			const lastLogin = existingUser.lastLoginAt instanceof Timestamp
				? existingUser.lastLoginAt.toDate()
				: new Date(existingUser.lastLoginAt as any);

			const timeDiff = now.getTime() - lastLogin.getTime();
			const fiveMinutesInMs = 5 * 60 * 1000; // 5åˆ†

			if (timeDiff > fiveMinutesInMs) {
				console.log('ğŸ”„ Updating lastLoginAt for user:', firebaseUser.uid);
				await updateLastLogin(firebaseUser.uid);
			} else {
				console.log('â­ï¸ Skipping lastLoginAt update (too recent):', firebaseUser.uid);
			}

			// æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦è¿”ã™
			const updatedUser = await getUserById(firebaseUser.uid);
			return updatedUser!;
		}
	} catch (error) {
		console.error('Error syncing auth with Firestore:', error);
		throw error;
	}
};

/**
 * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ç›£è¦–
 */
export const subscribeToUser = (
	userId: string,
	callback: (user: FirestoreUser | null) => void
): (() => void) => {
	const userRef = doc(db, USERS_COLLECTION, userId);

	return onSnapshot(userRef, (doc) => {
		if (doc.exists()) {
			callback({ id: doc.id, ...doc.data() } as FirestoreUser);
		} else {
			callback(null);
		}
	}, (error) => {
		console.error('Error subscribing to user:', error);
		callback(null);
	});
};

/**
 * ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å®Œæˆåº¦ã‚’ãƒã‚§ãƒƒã‚¯
 */
export const checkProfileCompleteness = (user: FirestoreUser): ProfileCompleteness => {
	const requiredFields: (keyof FirestoreUser)[] = [
		'displayName',
		'address'
	];

	const missingFields: string[] = [];
	let completedFields = 0;

	// åŸºæœ¬æƒ…å ±ãƒã‚§ãƒƒã‚¯
	if (!user.displayName?.trim()) {
		missingFields.push('Display Name');
	} else {
		completedFields++;
	}

	// ä½æ‰€æƒ…å ±ãƒã‚§ãƒƒã‚¯
	if (!user.address?.country || !user.address?.prefecture ||
		!user.address?.city || !user.address?.addressLine1 ||
		!user.address?.postalCode) {
		missingFields.push('Address Information');
	} else {
		completedFields++;
	}

	const completionPercentage = Math.round((completedFields / requiredFields.length) * 100);
	const isComplete = missingFields.length === 0;

	return {
		isComplete,
		completionPercentage,
		missingFields,
		requiredFields
	};
};

/**
 * FirestoreUserã‚’æ—¢å­˜ã®UserProfileå½¢å¼ã«å¤‰æ›
 */
export const firestoreUserToUserProfile = (firestoreUser: FirestoreUser): UserProfile => {
	return {
		walletAddress: firestoreUser.walletAddress || firestoreUser.id,
		displayName: firestoreUser.displayName,
		totalSpent: firestoreUser.stats.totalSpent,
		totalOrders: firestoreUser.stats.totalOrders,
		rank: firestoreUser.stats.rank,
		badges: firestoreUser.stats.badges,
		joinDate: firestoreUser.createdAt instanceof Timestamp
			? firestoreUser.createdAt.toDate()
			: new Date(firestoreUser.createdAt as any)
	};
};